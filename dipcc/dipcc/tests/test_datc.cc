
// This file is auto-generated by render_tests.py
//
#include "../cc/game.h"
#include "../cc/hash.h"
#include "../cc/thirdparty/nlohmann/json.hpp"
#include "consts.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include <vector>

using namespace std;

namespace dipcc {

class DATCTest : public ::testing::Test {};

// 6.A.1 TEST CASE, MOVING TO AN AREA THAT IS NOT A NEIGHBOUR
TEST_F(DATCTest, Test6A1) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F NTH - PIC"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.A.2. TEST CASE, MOVE ARMY TO SEA
TEST_F(DATCTest, Test6A2) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LVP);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("A LVP - IRI"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.A.3. TEST CASE, MOVE FLEET TO LAND
TEST_F(DATCTest, Test6A3) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::KIE);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("F KIE - MUN"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.A.4. TEST CASE, MOVE TO OWN SECTOR
TEST_F(DATCTest, Test6A4) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::KIE);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("F KIE - KIE"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.A.5. TEST CASE, MOVE TO OWN SECTOR WITH CONVOY
TEST_F(DATCTest, Test6A5) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::YOR);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LVP);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::LON);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::WAL);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F NTH C A YOR - YOR"));
  orders[Power::ENGLAND].push_back(Order("A YOR - YOR"));
  orders[Power::ENGLAND].push_back(Order("A LVP S A YOR - YOR"));
  orders[Power::GERMANY].push_back(Order("F LON - YOR"));
  orders[Power::GERMANY].push_back(Order("A WAL S F LON - YOR"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: F LON - YOR
  EXPECT_TRUE(state.get_unit(Loc::LON).power == next.get_unit(Loc::YOR).power &&
              state.get_unit(Loc::LON).type == next.get_unit(Loc::YOR).type);
}

// 6.A.6. TEST CASE, ORDERING A UNIT OF ANOTHER COUNTRY
TEST_F(DATCTest, Test6A6) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::LON);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("F LON - NTH"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.A.7. TEST CASE, ONLY ARMIES CAN BE CONVOYED
TEST_F(DATCTest, Test6A7) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::LON);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F LON - BEL"));
  orders[Power::ENGLAND].push_back(Order("F NTH C A LON - BEL"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.A.8. TEST CASE, SUPPORT TO HOLD YOURSELF IS NOT POSSIBLE
TEST_F(DATCTest, Test6A8) {
  GameState state;
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::VEN);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::TYR);
  state.set_unit(Power::AUSTRIA, UnitType::FLEET, Loc::TRI);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ITALY].push_back(Order("A VEN - TRI"));
  orders[Power::ITALY].push_back(Order("A TYR S A VEN - TRI"));
  orders[Power::AUSTRIA].push_back(Order("F TRI S F TRI"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A VEN - TRI
  EXPECT_TRUE(state.get_unit(Loc::VEN).power == next.get_unit(Loc::TRI).power &&
              state.get_unit(Loc::VEN).type == next.get_unit(Loc::TRI).type);
}

// 6.A.9. TEST CASE, FLEETS MUST FOLLOW COAST IF NOT ON SEA
TEST_F(DATCTest, Test6A9) {
  GameState state;
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::ROM);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ITALY].push_back(Order("F ROM - VEN"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.A.10. TEST CASE, SUPPORT ON UNREACHABLE DESTINATION NOT POSSIBLE
TEST_F(DATCTest, Test6A10) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::VEN);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::ROM);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::APU);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("A VEN H"));
  orders[Power::ITALY].push_back(Order("F ROM S A APU - VEN"));
  orders[Power::ITALY].push_back(Order("A APU - VEN"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.A.11. TEST CASE, SIMPLE BOUNCE
TEST_F(DATCTest, Test6A11) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::VIE);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::VEN);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("A VIE - TYR"));
  orders[Power::ITALY].push_back(Order("A VEN - TYR"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.A.12. TEST CASE, BOUNCE OF THREE UNITS
TEST_F(DATCTest, Test6A12) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::VIE);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::MUN);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::VEN);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("A VIE - TYR"));
  orders[Power::GERMANY].push_back(Order("A MUN - TYR"));
  orders[Power::ITALY].push_back(Order("A VEN - TYR"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.B.1. TEST CASE, MOVING WITH UNSPECIFIED COAST WHEN COAST IS NECESSARY
TEST_F(DATCTest, Test6B1) {
  GameState state;
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::POR);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::FRANCE].push_back(Order("F POR - SPA"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.B.2. TEST CASE, MOVING WITH UNSPECIFIED COAST WHEN COAST IS NOT NECESSARY
TEST_F(DATCTest, Test6B2) {
  GameState state;
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::GAS);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::FRANCE].push_back(Order("F GAS - SPA"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.B.3. TEST CASE, MOVING WITH WRONG COAST WHEN COAST IS NOT NECESSARY
TEST_F(DATCTest, Test6B3) {
  GameState state;
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::GAS);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::FRANCE].push_back(Order("F GAS - SPA/SC"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.B.4. TEST CASE, SUPPORT TO UNREACHABLE COAST ALLOWED
TEST_F(DATCTest, Test6B4) {
  GameState state;
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::GAS);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::MAR);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::WES);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::FRANCE].push_back(Order("F GAS - SPA/NC"));
  orders[Power::FRANCE].push_back(Order("F MAR S F GAS - SPA/NC"));
  orders[Power::ITALY].push_back(Order("F WES - SPA/SC"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: F GAS - SPA/NC
  EXPECT_TRUE(state.get_unit(Loc::GAS).power ==
                  next.get_unit(Loc::SPA_NC).power &&
              state.get_unit(Loc::GAS).type == next.get_unit(Loc::SPA_NC).type);
}

// 6.B.5. TEST CASE, SUPPORT FROM UNREACHABLE COAST NOT ALLOWED
TEST_F(DATCTest, Test6B5) {
  GameState state;
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::MAR);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::SPA_NC);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::LYO);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::FRANCE].push_back(Order("F MAR - LYO"));
  orders[Power::FRANCE].push_back(Order("F SPA/NC S F MAR - LYO"));
  orders[Power::ITALY].push_back(Order("F LYO H"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.B.6. TEST CASE, SUPPORT CAN BE CUT WITH OTHER COAST
TEST_F(DATCTest, Test6B6) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::IRI);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NAO);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::SPA_NC);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::MAO);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::LYO);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F IRI S F NAO - MAO"));
  orders[Power::ENGLAND].push_back(Order("F NAO - MAO"));
  orders[Power::FRANCE].push_back(Order("F SPA/NC S F MAO"));
  orders[Power::FRANCE].push_back(Order("F MAO H"));
  orders[Power::ITALY].push_back(Order("F LYO - SPA/SC"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: F NAO - MAO
  EXPECT_TRUE(state.get_unit(Loc::NAO).power == next.get_unit(Loc::MAO).power &&
              state.get_unit(Loc::NAO).type == next.get_unit(Loc::MAO).type);
}

// 6.B.7. TEST CASE, SUPPORTING WITH UNSPECIFIED COAST
TEST_F(DATCTest, Test6B7) {
  GameState state;
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::POR);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::MAO);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::LYO);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::WES);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::FRANCE].push_back(Order("F POR S F MAO - SPA"));
  orders[Power::FRANCE].push_back(Order("F MAO - SPA/NC"));
  orders[Power::ITALY].push_back(Order("F LYO S F WES - SPA/SC"));
  orders[Power::ITALY].push_back(Order("F WES - SPA/SC"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect failure: F WES - SPA/SC
  EXPECT_FALSE(
      state.get_unit(Loc::WES).power == next.get_unit(Loc::SPA_SC).power &&
      state.get_unit(Loc::WES).type == next.get_unit(Loc::SPA_SC).type);
}

// 6.B.8. TEST CASE, SUPPORTING WITH UNSPECIFIED COAST WHEN ONLY ONE COAST IS
// POSSIBLE
TEST_F(DATCTest, Test6B8) {
  GameState state;
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::POR);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::GAS);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::LYO);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::WES);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::FRANCE].push_back(Order("F POR S F GAS - SPA"));
  orders[Power::FRANCE].push_back(Order("F GAS - SPA/NC"));
  orders[Power::ITALY].push_back(Order("F LYO S F WES - SPA/SC"));
  orders[Power::ITALY].push_back(Order("F WES - SPA/SC"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect failure: F WES - SPA/SC
  EXPECT_FALSE(
      state.get_unit(Loc::WES).power == next.get_unit(Loc::SPA_SC).power &&
      state.get_unit(Loc::WES).type == next.get_unit(Loc::SPA_SC).type);
}

// 6.B.9. TEST CASE, SUPPORTING WITH WRONG COAST
TEST_F(DATCTest, Test6B9) {
  GameState state;
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::POR);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::MAO);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::LYO);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::WES);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::FRANCE].push_back(Order("F POR S F MAO - SPA/NC"));
  orders[Power::FRANCE].push_back(Order("F MAO - SPA/SC"));
  orders[Power::ITALY].push_back(Order("F LYO S F WES - SPA/SC"));
  orders[Power::ITALY].push_back(Order("F WES - SPA/SC"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: F WES - SPA/SC
  EXPECT_TRUE(state.get_unit(Loc::WES).power ==
                  next.get_unit(Loc::SPA_SC).power &&
              state.get_unit(Loc::WES).type == next.get_unit(Loc::SPA_SC).type);
}

// 6.B.10. TEST CASE, UNIT ORDERED WITH WRONG COAST
TEST_F(DATCTest, Test6B10) {
  GameState state;
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::SPA_NC);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::FRANCE].push_back(Order("F SPA/NC - LYO"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.B.12. TEST CASE, ARMY MOVEMENT WITH COASTAL SPECIFICATION
TEST_F(DATCTest, Test6B12) {
  GameState state;
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::GAS);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::FRANCE].push_back(Order("A GAS - SPA/NC"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.B.13. TEST CASE, COASTAL CRAWL NOT ALLOWED
TEST_F(DATCTest, Test6B13) {
  GameState state;
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::BUL_SC);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::CON);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::BUL_SC);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::TURKEY].push_back(Order("F BUL/SC - CON"));
  orders[Power::TURKEY].push_back(Order("F CON - BUL/EC"));
  orders[Power::RUSSIA].push_back(Order("F BUL/SC - CON"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.C.1. TEST CASE, THREE ARMY CIRCULAR MOVEMENT
TEST_F(DATCTest, Test6C1) {
  GameState state;
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::ANK);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::CON);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::SMY);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::TURKEY].push_back(Order("F ANK - CON"));
  orders[Power::TURKEY].push_back(Order("A CON - SMY"));
  orders[Power::TURKEY].push_back(Order("A SMY - ANK"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: F ANK - CON
  EXPECT_TRUE(state.get_unit(Loc::ANK).power == next.get_unit(Loc::CON).power &&
              state.get_unit(Loc::ANK).type == next.get_unit(Loc::CON).type);
  // expect success: A CON - SMY
  EXPECT_TRUE(state.get_unit(Loc::CON).power == next.get_unit(Loc::SMY).power &&
              state.get_unit(Loc::CON).type == next.get_unit(Loc::SMY).type);
  // expect success: A SMY - ANK
  EXPECT_TRUE(state.get_unit(Loc::SMY).power == next.get_unit(Loc::ANK).power &&
              state.get_unit(Loc::SMY).type == next.get_unit(Loc::ANK).type);
}

// 6.C.2. TEST CASE, THREE ARMY CIRCULAR MOVEMENT WITH SUPPORT
TEST_F(DATCTest, Test6C2) {
  GameState state;
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::ANK);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::CON);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::SMY);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::BUL);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::TURKEY].push_back(Order("F ANK - CON"));
  orders[Power::TURKEY].push_back(Order("A CON - SMY"));
  orders[Power::TURKEY].push_back(Order("A SMY - ANK"));
  orders[Power::TURKEY].push_back(Order("A BUL S F ANK - CON"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: F ANK - CON
  EXPECT_TRUE(state.get_unit(Loc::ANK).power == next.get_unit(Loc::CON).power &&
              state.get_unit(Loc::ANK).type == next.get_unit(Loc::CON).type);
  // expect success: A CON - SMY
  EXPECT_TRUE(state.get_unit(Loc::CON).power == next.get_unit(Loc::SMY).power &&
              state.get_unit(Loc::CON).type == next.get_unit(Loc::SMY).type);
  // expect success: A SMY - ANK
  EXPECT_TRUE(state.get_unit(Loc::SMY).power == next.get_unit(Loc::ANK).power &&
              state.get_unit(Loc::SMY).type == next.get_unit(Loc::ANK).type);
}

// 6.C.3. TEST CASE, A DISRUPTED THREE ARMY CIRCULAR MOVEMENT
TEST_F(DATCTest, Test6C3) {
  GameState state;
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::ANK);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::CON);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::SMY);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::BUL);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::TURKEY].push_back(Order("F ANK - CON"));
  orders[Power::TURKEY].push_back(Order("A CON - SMY"));
  orders[Power::TURKEY].push_back(Order("A SMY - ANK"));
  orders[Power::TURKEY].push_back(Order("A BUL - CON"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.C.4. TEST CASE, A CIRCULAR MOVEMENT WITH ATTACKED CONVOY
TEST_F(DATCTest, Test6C4) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::TRI);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::SER);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::BUL);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::AEG);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::ION);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::ADR);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::NAP);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("A TRI - SER"));
  orders[Power::AUSTRIA].push_back(Order("A SER - BUL"));
  orders[Power::TURKEY].push_back(Order("A BUL - TRI"));
  orders[Power::TURKEY].push_back(Order("F AEG C A BUL - TRI"));
  orders[Power::TURKEY].push_back(Order("F ION C A BUL - TRI"));
  orders[Power::TURKEY].push_back(Order("F ADR C A BUL - TRI"));
  orders[Power::ITALY].push_back(Order("F NAP - ION"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A TRI - SER
  EXPECT_TRUE(state.get_unit(Loc::TRI).power == next.get_unit(Loc::SER).power &&
              state.get_unit(Loc::TRI).type == next.get_unit(Loc::SER).type);
  // expect success: A SER - BUL
  EXPECT_TRUE(state.get_unit(Loc::SER).power == next.get_unit(Loc::BUL).power &&
              state.get_unit(Loc::SER).type == next.get_unit(Loc::BUL).type);
  // expect success: A BUL - TRI
  EXPECT_TRUE(state.get_unit(Loc::BUL).power == next.get_unit(Loc::TRI).power &&
              state.get_unit(Loc::BUL).type == next.get_unit(Loc::TRI).type);
}

// 6.C.5. TEST CASE, A DISRUPTED CIRCULAR MOVEMENT DUE TO DISLODGED CONVOY
TEST_F(DATCTest, Test6C5) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::TRI);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::SER);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::BUL);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::AEG);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::ION);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::ADR);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::NAP);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::TUN);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("A TRI - SER"));
  orders[Power::AUSTRIA].push_back(Order("A SER - BUL"));
  orders[Power::TURKEY].push_back(Order("A BUL - TRI"));
  orders[Power::TURKEY].push_back(Order("F AEG C A BUL - TRI"));
  orders[Power::TURKEY].push_back(Order("F ION C A BUL - TRI"));
  orders[Power::TURKEY].push_back(Order("F ADR C A BUL - TRI"));
  orders[Power::ITALY].push_back(Order("F NAP - ION"));
  orders[Power::ITALY].push_back(Order("F TUN S F NAP - ION"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: F NAP - ION
  EXPECT_TRUE(state.get_unit(Loc::NAP).power == next.get_unit(Loc::ION).power &&
              state.get_unit(Loc::NAP).type == next.get_unit(Loc::ION).type);
}

// 6.C.6. TEST CASE, TWO ARMIES WITH TWO CONVOYS
TEST_F(DATCTest, Test6C6) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LON);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::BEL);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F NTH C A LON - BEL"));
  orders[Power::ENGLAND].push_back(Order("A LON - BEL"));
  orders[Power::FRANCE].push_back(Order("F ENG C A BEL - LON"));
  orders[Power::FRANCE].push_back(Order("A BEL - LON"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A LON - BEL
  EXPECT_TRUE(state.get_unit(Loc::LON).power == next.get_unit(Loc::BEL).power &&
              state.get_unit(Loc::LON).type == next.get_unit(Loc::BEL).type);
  // expect success: A BEL - LON
  EXPECT_TRUE(state.get_unit(Loc::BEL).power == next.get_unit(Loc::LON).power &&
              state.get_unit(Loc::BEL).type == next.get_unit(Loc::LON).type);
}

// 6.C.7. TEST CASE, DISRUPTED UNIT SWAP
TEST_F(DATCTest, Test6C7) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LON);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::BEL);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::BUR);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F NTH C A LON - BEL"));
  orders[Power::ENGLAND].push_back(Order("A LON - BEL"));
  orders[Power::FRANCE].push_back(Order("F ENG C A BEL - LON"));
  orders[Power::FRANCE].push_back(Order("A BEL - LON"));
  orders[Power::FRANCE].push_back(Order("A BUR - BEL"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.D.1. TEST CASE, SUPPORTED HOLD CAN PREVENT DISLODGEMENT
TEST_F(DATCTest, Test6D1) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::FLEET, Loc::ADR);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::TRI);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::VEN);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::TYR);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("F ADR S A TRI - VEN"));
  orders[Power::AUSTRIA].push_back(Order("A TRI - VEN"));
  orders[Power::ITALY].push_back(Order("A VEN H"));
  orders[Power::ITALY].push_back(Order("A TYR S A VEN"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.D.2. TEST CASE, A MOVE CUTS SUPPORT ON HOLD
TEST_F(DATCTest, Test6D2) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::FLEET, Loc::ADR);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::TRI);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::VIE);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::VEN);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::TYR);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("F ADR S A TRI - VEN"));
  orders[Power::AUSTRIA].push_back(Order("A TRI - VEN"));
  orders[Power::AUSTRIA].push_back(Order("A VIE - TYR"));
  orders[Power::ITALY].push_back(Order("A VEN H"));
  orders[Power::ITALY].push_back(Order("A TYR S A VEN"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A TRI - VEN
  EXPECT_TRUE(state.get_unit(Loc::TRI).power == next.get_unit(Loc::VEN).power &&
              state.get_unit(Loc::TRI).type == next.get_unit(Loc::VEN).type);
}

// 6.D.3. TEST CASE, A MOVE CUTS SUPPORT ON MOVE
TEST_F(DATCTest, Test6D3) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::FLEET, Loc::ADR);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::TRI);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::VEN);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::ION);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("F ADR S A TRI - VEN"));
  orders[Power::AUSTRIA].push_back(Order("A TRI - VEN"));
  orders[Power::ITALY].push_back(Order("A VEN H"));
  orders[Power::ITALY].push_back(Order("F ION - ADR"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.D.4. TEST CASE, SUPPORT TO HOLD ON UNIT SUPPORTING A HOLD ALLOWED
TEST_F(DATCTest, Test6D4) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BER);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::KIE);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::BAL);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::PRU);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("A BER S F KIE"));
  orders[Power::GERMANY].push_back(Order("F KIE S A BER"));
  orders[Power::RUSSIA].push_back(Order("F BAL S A PRU - BER"));
  orders[Power::RUSSIA].push_back(Order("A PRU - BER"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.D.5. TEST CASE, SUPPORT TO HOLD ON UNIT SUPPORTING A MOVE ALLOWED
TEST_F(DATCTest, Test6D5) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BER);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::KIE);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::MUN);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::BAL);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::PRU);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("A BER S A MUN - SIL"));
  orders[Power::GERMANY].push_back(Order("F KIE S A BER"));
  orders[Power::GERMANY].push_back(Order("A MUN - SIL"));
  orders[Power::RUSSIA].push_back(Order("F BAL S A PRU - BER"));
  orders[Power::RUSSIA].push_back(Order("A PRU - BER"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect failure: A PRU - BER
  EXPECT_FALSE(state.get_unit(Loc::PRU).power ==
                   next.get_unit(Loc::BER).power &&
               state.get_unit(Loc::PRU).type == next.get_unit(Loc::BER).type);
}

// 6.D.6. TEST CASE, SUPPORT TO HOLD ON CONVOYING UNIT ALLOWED
TEST_F(DATCTest, Test6D6) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BER);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::BAL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::PRU);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::LVN);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::BOT);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("A BER - SWE"));
  orders[Power::GERMANY].push_back(Order("F BAL C A BER - SWE"));
  orders[Power::GERMANY].push_back(Order("F PRU S F BAL"));
  orders[Power::RUSSIA].push_back(Order("F LVN - BAL"));
  orders[Power::RUSSIA].push_back(Order("F BOT S F LVN - BAL"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A BER - SWE
  EXPECT_TRUE(state.get_unit(Loc::BER).power == next.get_unit(Loc::SWE).power &&
              state.get_unit(Loc::BER).type == next.get_unit(Loc::SWE).type);
}

// 6.D.8. TEST CASE, FAILED CONVOY CAN NOT RECEIVE HOLD SUPPORT
TEST_F(DATCTest, Test6D8) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::FLEET, Loc::ION);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::SER);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::ALB);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::GRE);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::BUL);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("F ION H"));
  orders[Power::AUSTRIA].push_back(Order("A SER S A ALB - GRE"));
  orders[Power::AUSTRIA].push_back(Order("A ALB - GRE"));
  orders[Power::TURKEY].push_back(Order("A GRE - NAP"));
  orders[Power::TURKEY].push_back(Order("A BUL S A GRE"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A ALB - GRE
  EXPECT_TRUE(state.get_unit(Loc::ALB).power == next.get_unit(Loc::GRE).power &&
              state.get_unit(Loc::ALB).type == next.get_unit(Loc::GRE).type);
}

// 6.D.9. TEST CASE, SUPPORT TO MOVE ON HOLDING UNIT NOT ALLOWED
TEST_F(DATCTest, Test6D9) {
  GameState state;
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::VEN);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::TYR);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::ALB);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::TRI);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ITALY].push_back(Order("A VEN - TRI"));
  orders[Power::ITALY].push_back(Order("A TYR S A VEN - TRI"));
  orders[Power::AUSTRIA].push_back(Order("A ALB S A TRI - SER"));
  orders[Power::AUSTRIA].push_back(Order("A TRI H"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A VEN - TRI
  EXPECT_TRUE(state.get_unit(Loc::VEN).power == next.get_unit(Loc::TRI).power &&
              state.get_unit(Loc::VEN).type == next.get_unit(Loc::TRI).type);
}

// 6.D.10. TEST CASE, SELF DISLODGMENT PROHIBITED
TEST_F(DATCTest, Test6D10) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BER);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::KIE);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::MUN);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("A BER H"));
  orders[Power::GERMANY].push_back(Order("F KIE - BER"));
  orders[Power::GERMANY].push_back(Order("A MUN S F KIE - BER"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.D.11. TEST CASE, NO SELF DISLODGMENT OF RETURNING UNIT
TEST_F(DATCTest, Test6D11) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BER);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::KIE);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::MUN);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::WAR);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("A BER - PRU"));
  orders[Power::GERMANY].push_back(Order("F KIE - BER"));
  orders[Power::GERMANY].push_back(Order("A MUN S F KIE - BER"));
  orders[Power::RUSSIA].push_back(Order("A WAR - PRU"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.D.12. TEST CASE, SUPPORTING A FOREIGN UNIT TO DISLODGE OWN UNIT PROHIBITED
TEST_F(DATCTest, Test6D12) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::FLEET, Loc::TRI);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::VIE);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::VEN);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("F TRI H"));
  orders[Power::AUSTRIA].push_back(Order("A VIE S A VEN - TRI"));
  orders[Power::ITALY].push_back(Order("A VEN - TRI"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.D.13. TEST CASE, SUPPORTING A FOREIGN UNIT TO DISLODGE A RETURNING OWN UNIT
// PROHIBITED
TEST_F(DATCTest, Test6D13) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::FLEET, Loc::TRI);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::VIE);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::VEN);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::APU);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("F TRI - ADR"));
  orders[Power::AUSTRIA].push_back(Order("A VIE S A VEN - TRI"));
  orders[Power::ITALY].push_back(Order("A VEN - TRI"));
  orders[Power::ITALY].push_back(Order("F APU - ADR"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.D.14. TEST CASE, SUPPORTING A FOREIGN UNIT IS NOT ENOUGH TO PREVENT
// DISLODGEMENT
TEST_F(DATCTest, Test6D14) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::FLEET, Loc::TRI);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::VIE);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::VEN);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::TYR);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::ADR);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("F TRI H"));
  orders[Power::AUSTRIA].push_back(Order("A VIE S A VEN - TRI"));
  orders[Power::ITALY].push_back(Order("A VEN - TRI"));
  orders[Power::ITALY].push_back(Order("A TYR S A VEN - TRI"));
  orders[Power::ITALY].push_back(Order("F ADR S A VEN - TRI"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A VEN - TRI
  EXPECT_TRUE(state.get_unit(Loc::VEN).power == next.get_unit(Loc::TRI).power &&
              state.get_unit(Loc::VEN).type == next.get_unit(Loc::TRI).type);
}

// 6.D.15. TEST CASE, DEFENDER CAN NOT CUT SUPPORT FOR ATTACK ON ITSELF
TEST_F(DATCTest, Test6D15) {
  GameState state;
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::CON);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::BLA);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::ANK);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::RUSSIA].push_back(Order("F CON S F BLA - ANK"));
  orders[Power::RUSSIA].push_back(Order("F BLA - ANK"));
  orders[Power::TURKEY].push_back(Order("F ANK - CON"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: F BLA - ANK
  EXPECT_TRUE(state.get_unit(Loc::BLA).power == next.get_unit(Loc::ANK).power &&
              state.get_unit(Loc::BLA).type == next.get_unit(Loc::ANK).type);
}

// 6.D.16. TEST CASE, CONVOYING A UNIT DISLODGING A UNIT OF SAME POWER IS
// ALLOWED
TEST_F(DATCTest, Test6D16) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LON);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::BEL);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("A LON H"));
  orders[Power::ENGLAND].push_back(Order("F NTH C A BEL - LON"));
  orders[Power::FRANCE].push_back(Order("F ENG S A BEL - LON"));
  orders[Power::FRANCE].push_back(Order("A BEL - LON"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A BEL - LON
  EXPECT_TRUE(state.get_unit(Loc::BEL).power == next.get_unit(Loc::LON).power &&
              state.get_unit(Loc::BEL).type == next.get_unit(Loc::LON).type);
}

// 6.D.17. TEST CASE, DISLODGEMENT CUTS SUPPORTS
TEST_F(DATCTest, Test6D17) {
  GameState state;
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::CON);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::BLA);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::ANK);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::SMY);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::ARM);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::RUSSIA].push_back(Order("F CON S F BLA - ANK"));
  orders[Power::RUSSIA].push_back(Order("F BLA - ANK"));
  orders[Power::TURKEY].push_back(Order("F ANK - CON"));
  orders[Power::TURKEY].push_back(Order("A SMY S F ANK - CON"));
  orders[Power::TURKEY].push_back(Order("A ARM - ANK"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: F ANK - CON
  EXPECT_TRUE(state.get_unit(Loc::ANK).power == next.get_unit(Loc::CON).power &&
              state.get_unit(Loc::ANK).type == next.get_unit(Loc::CON).type);
  // expect failure: F BLA - ANK
  EXPECT_FALSE(state.get_unit(Loc::BLA).power ==
                   next.get_unit(Loc::ANK).power &&
               state.get_unit(Loc::BLA).type == next.get_unit(Loc::ANK).type);
  // expect failure: A ARM - ANK
  EXPECT_FALSE(state.get_unit(Loc::ARM).power ==
                   next.get_unit(Loc::ANK).power &&
               state.get_unit(Loc::ARM).type == next.get_unit(Loc::ANK).type);
}

// 6.D.18. TEST CASE, A SURVIVING UNIT WILL SUSTAIN SUPPORT
TEST_F(DATCTest, Test6D18) {
  GameState state;
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::CON);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::BLA);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::BUL);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::ANK);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::SMY);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::ARM);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::RUSSIA].push_back(Order("F CON S F BLA - ANK"));
  orders[Power::RUSSIA].push_back(Order("F BLA - ANK"));
  orders[Power::RUSSIA].push_back(Order("A BUL S F CON"));
  orders[Power::TURKEY].push_back(Order("F ANK - CON"));
  orders[Power::TURKEY].push_back(Order("A SMY S F ANK - CON"));
  orders[Power::TURKEY].push_back(Order("A ARM - ANK"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: F BLA - ANK
  EXPECT_TRUE(state.get_unit(Loc::BLA).power == next.get_unit(Loc::ANK).power &&
              state.get_unit(Loc::BLA).type == next.get_unit(Loc::ANK).type);
}

// 6.D.19. TEST CASE, EVEN WHEN SURVIVING IS IN ALTERNATIVE WAY
TEST_F(DATCTest, Test6D19) {
  GameState state;
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::CON);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::BLA);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::SMY);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::ANK);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::RUSSIA].push_back(Order("F CON S F BLA - ANK"));
  orders[Power::RUSSIA].push_back(Order("F BLA - ANK"));
  orders[Power::RUSSIA].push_back(Order("A SMY S F ANK - CON"));
  orders[Power::TURKEY].push_back(Order("F ANK - CON"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: F BLA - ANK
  EXPECT_TRUE(state.get_unit(Loc::BLA).power == next.get_unit(Loc::ANK).power &&
              state.get_unit(Loc::BLA).type == next.get_unit(Loc::ANK).type);
}

// 6.D.20. TEST CASE, UNIT CAN NOT CUT SUPPORT OF ITS OWN COUNTRY
TEST_F(DATCTest, Test6D20) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::LON);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::YOR);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::ENG);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F LON S F NTH - ENG"));
  orders[Power::ENGLAND].push_back(Order("F NTH - ENG"));
  orders[Power::ENGLAND].push_back(Order("A YOR - LON"));
  orders[Power::FRANCE].push_back(Order("F ENG H"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: F NTH - ENG
  EXPECT_TRUE(state.get_unit(Loc::NTH).power == next.get_unit(Loc::ENG).power &&
              state.get_unit(Loc::NTH).type == next.get_unit(Loc::ENG).type);
}

// 6.D.21. TEST CASE, DISLODGING DOES NOT CANCEL A SUPPORT CUT
TEST_F(DATCTest, Test6D21) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::FLEET, Loc::TRI);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::VEN);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::TYR);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::MUN);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::SIL);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::BER);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("F TRI H"));
  orders[Power::ITALY].push_back(Order("A VEN - TRI"));
  orders[Power::ITALY].push_back(Order("A TYR S A VEN - TRI"));
  orders[Power::GERMANY].push_back(Order("A MUN - TYR"));
  orders[Power::RUSSIA].push_back(Order("A SIL - MUN"));
  orders[Power::RUSSIA].push_back(Order("A BER S A SIL - MUN"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect failure: A VEN - TRI
  EXPECT_FALSE(state.get_unit(Loc::VEN).power ==
                   next.get_unit(Loc::TRI).power &&
               state.get_unit(Loc::VEN).type == next.get_unit(Loc::TRI).type);
  // expect failure: A MUN - TYR
  EXPECT_FALSE(state.get_unit(Loc::MUN).power ==
                   next.get_unit(Loc::TYR).power &&
               state.get_unit(Loc::MUN).type == next.get_unit(Loc::TYR).type);
  // expect success: A SIL - MUN
  EXPECT_TRUE(state.get_unit(Loc::SIL).power == next.get_unit(Loc::MUN).power &&
              state.get_unit(Loc::SIL).type == next.get_unit(Loc::MUN).type);
}

// 6.D.22. TEST CASE, IMPOSSIBLE FLEET MOVE CAN NOT BE SUPPORTED
TEST_F(DATCTest, Test6D22) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::KIE);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BUR);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::MUN);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::BER);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("F KIE - MUN"));
  orders[Power::GERMANY].push_back(Order("A BUR S F KIE - MUN"));
  orders[Power::RUSSIA].push_back(Order("A MUN - KIE"));
  orders[Power::RUSSIA].push_back(Order("A BER S A MUN - KIE"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect failure: F KIE - MUN
  EXPECT_FALSE(state.get_unit(Loc::KIE).power ==
                   next.get_unit(Loc::MUN).power &&
               state.get_unit(Loc::KIE).type == next.get_unit(Loc::MUN).type);
  // expect failure: F KIE - MUN
  EXPECT_FALSE(state.get_unit(Loc::KIE).power ==
                   next.get_unit(Loc::MUN).power &&
               state.get_unit(Loc::KIE).type == next.get_unit(Loc::MUN).type);
  // expect success: A MUN - KIE
  EXPECT_TRUE(state.get_unit(Loc::MUN).power == next.get_unit(Loc::KIE).power &&
              state.get_unit(Loc::MUN).type == next.get_unit(Loc::KIE).type);
}

// 6.D.23. TEST CASE, IMPOSSIBLE COAST MOVE CAN NOT BE SUPPORTED
TEST_F(DATCTest, Test6D23) {
  GameState state;
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::LYO);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::WES);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::SPA_NC);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::MAR);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ITALY].push_back(Order("F LYO - SPA/SC"));
  orders[Power::ITALY].push_back(Order("F WES S F LYO - SPA/SC"));
  orders[Power::FRANCE].push_back(Order("F SPA/NC - LYO"));
  orders[Power::FRANCE].push_back(Order("F MAR S F SPA/NC - LYO"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect failure: F SPA/NC - LYO
  EXPECT_FALSE(
      state.get_unit(Loc::SPA_NC).power == next.get_unit(Loc::LYO).power &&
      state.get_unit(Loc::SPA_NC).type == next.get_unit(Loc::LYO).type);
  // expect failure: F SPA/NC - LYO
  EXPECT_FALSE(
      state.get_unit(Loc::SPA_NC).power == next.get_unit(Loc::LYO).power &&
      state.get_unit(Loc::SPA_NC).type == next.get_unit(Loc::LYO).type);
  // expect success: F LYO - SPA/SC
  EXPECT_TRUE(state.get_unit(Loc::LYO).power ==
                  next.get_unit(Loc::SPA_SC).power &&
              state.get_unit(Loc::LYO).type == next.get_unit(Loc::SPA_SC).type);
}

// 6.D.24. TEST CASE, IMPOSSIBLE ARMY MOVE CAN NOT BE SUPPORTED
TEST_F(DATCTest, Test6D24) {
  GameState state;
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::MAR);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::SPA_SC);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::LYO);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::TYS);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::WES);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::FRANCE].push_back(Order("A MAR - LYO"));
  orders[Power::FRANCE].push_back(Order("F SPA/SC S A MAR - LYO"));
  orders[Power::ITALY].push_back(Order("F LYO H"));
  orders[Power::TURKEY].push_back(Order("F TYS S F WES - LYO"));
  orders[Power::TURKEY].push_back(Order("F WES - LYO"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect failure: A MAR - LYO
  EXPECT_FALSE(state.get_unit(Loc::MAR).power ==
                   next.get_unit(Loc::LYO).power &&
               state.get_unit(Loc::MAR).type == next.get_unit(Loc::LYO).type);
  // expect failure: A MAR - LYO
  EXPECT_FALSE(state.get_unit(Loc::MAR).power ==
                   next.get_unit(Loc::LYO).power &&
               state.get_unit(Loc::MAR).type == next.get_unit(Loc::LYO).type);
  // expect success: F WES - LYO
  EXPECT_TRUE(state.get_unit(Loc::WES).power == next.get_unit(Loc::LYO).power &&
              state.get_unit(Loc::WES).type == next.get_unit(Loc::LYO).type);
}

// 6.D.25. TEST CASE, FAILING HOLD SUPPORT CAN BE SUPPORTED
TEST_F(DATCTest, Test6D25) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BER);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::KIE);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::BAL);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::PRU);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("A BER S A PRU"));
  orders[Power::GERMANY].push_back(Order("F KIE S A BER"));
  orders[Power::RUSSIA].push_back(Order("F BAL S A PRU - BER"));
  orders[Power::RUSSIA].push_back(Order("A PRU - BER"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.D.26. TEST CASE, FAILING MOVE SUPPORT CAN BE SUPPORTED
TEST_F(DATCTest, Test6D26) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BER);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::KIE);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::BAL);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::PRU);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("A BER S A PRU - SIL"));
  orders[Power::GERMANY].push_back(Order("F KIE S A BER"));
  orders[Power::RUSSIA].push_back(Order("F BAL S A PRU - BER"));
  orders[Power::RUSSIA].push_back(Order("A PRU - BER"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.D.27. TEST CASE, FAILING CONVOY CAN BE SUPPORTED
TEST_F(DATCTest, Test6D27) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::SWE);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::DEN);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BER);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::BAL);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::PRU);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F SWE - BAL"));
  orders[Power::ENGLAND].push_back(Order("F DEN S F SWE - BAL"));
  orders[Power::GERMANY].push_back(Order("A BER H"));
  orders[Power::RUSSIA].push_back(Order("F BAL C A BER - LVN"));
  orders[Power::RUSSIA].push_back(Order("F PRU S F BAL"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.D.28. TEST CASE, IMPOSSIBLE MOVE AND SUPPORT
TEST_F(DATCTest, Test6D28) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::BUD);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::RUM);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::BLA);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::BUL);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("A BUD S F RUM"));
  orders[Power::RUSSIA].push_back(Order("F RUM - HOL"));
  orders[Power::TURKEY].push_back(Order("F BLA - RUM"));
  orders[Power::TURKEY].push_back(Order("A BUL S F BLA - RUM"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.D.29. TEST CASE, MOVE TO IMPOSSIBLE COAST AND SUPPORT
TEST_F(DATCTest, Test6D29) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::BUD);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::RUM);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::BLA);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::BUL);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("A BUD S F RUM"));
  orders[Power::RUSSIA].push_back(Order("F RUM - BUL/SC"));
  orders[Power::TURKEY].push_back(Order("F BLA - RUM"));
  orders[Power::TURKEY].push_back(Order("A BUL S F BLA - RUM"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.D.30. TEST CASE, MOVE WITHOUT COAST AND SUPPORT
TEST_F(DATCTest, Test6D30) {
  GameState state;
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::AEG);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::CON);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::BLA);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::BUL);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ITALY].push_back(Order("F AEG S F CON"));
  orders[Power::RUSSIA].push_back(Order("F CON - BUL"));
  orders[Power::TURKEY].push_back(Order("F BLA - CON"));
  orders[Power::TURKEY].push_back(Order("A BUL S F BLA - CON"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.D.32. TEST CASE, A MISSING FLEET
TEST_F(DATCTest, Test6D32) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::EDI);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LVP);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::LON);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::YOR);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F EDI S A LVP - YOR"));
  orders[Power::ENGLAND].push_back(Order("A LVP - YOR"));
  orders[Power::FRANCE].push_back(Order("F LON S A YOR"));
  orders[Power::GERMANY].push_back(Order("A YOR - HOL"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.D.33. TEST CASE, UNWANTED SUPPORT ALLOWED
TEST_F(DATCTest, Test6D33) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::SER);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::VIE);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::GAL);
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::BUL);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("A SER - BUD"));
  orders[Power::AUSTRIA].push_back(Order("A VIE - BUD"));
  orders[Power::RUSSIA].push_back(Order("A GAL S A SER - BUD"));
  orders[Power::TURKEY].push_back(Order("A BUL - SER"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A SER - BUD
  EXPECT_TRUE(state.get_unit(Loc::SER).power == next.get_unit(Loc::BUD).power &&
              state.get_unit(Loc::SER).type == next.get_unit(Loc::BUD).type);
  // expect success: A BUL - SER
  EXPECT_TRUE(state.get_unit(Loc::BUL).power == next.get_unit(Loc::SER).power &&
              state.get_unit(Loc::BUL).type == next.get_unit(Loc::SER).type);
}

// 6.D.34. TEST CASE, SUPPORT TARGETING OWN AREA NOT ALLOWED
TEST_F(DATCTest, Test6D34) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BER);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::SIL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::BAL);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::PRU);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::WAR);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::LVN);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("A BER - PRU"));
  orders[Power::GERMANY].push_back(Order("A SIL S A BER - PRU"));
  orders[Power::GERMANY].push_back(Order("F BAL S A BER - PRU"));
  orders[Power::ITALY].push_back(Order("A PRU S A LVN - PRU"));
  orders[Power::RUSSIA].push_back(Order("A WAR S A LVN - PRU"));
  orders[Power::RUSSIA].push_back(Order("A LVN - PRU"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A BER - PRU
  EXPECT_TRUE(state.get_unit(Loc::BER).power == next.get_unit(Loc::PRU).power &&
              state.get_unit(Loc::BER).type == next.get_unit(Loc::PRU).type);
}

// 6.E.1. TEST CASE, DISLODGED UNIT HAS NO EFFECT ON ATTACKERS AREA
TEST_F(DATCTest, Test6E1) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BER);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::KIE);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::SIL);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::PRU);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("A BER - PRU"));
  orders[Power::GERMANY].push_back(Order("F KIE - BER"));
  orders[Power::GERMANY].push_back(Order("A SIL S A BER - PRU"));
  orders[Power::RUSSIA].push_back(Order("A PRU - BER"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: F KIE - BER
  EXPECT_TRUE(state.get_unit(Loc::KIE).power == next.get_unit(Loc::BER).power &&
              state.get_unit(Loc::KIE).type == next.get_unit(Loc::BER).type);
}

// 6.E.2. TEST CASE, NO SELF DISLODGEMENT IN HEAD TO HEAD BATTLE
TEST_F(DATCTest, Test6E2) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BER);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::KIE);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::MUN);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("A BER - KIE"));
  orders[Power::GERMANY].push_back(Order("F KIE - BER"));
  orders[Power::GERMANY].push_back(Order("A MUN S A BER - KIE"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.E.3. TEST CASE, NO HELP IN DISLODGING OWN UNIT
TEST_F(DATCTest, Test6E3) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BER);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::MUN);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::KIE);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("A BER - KIE"));
  orders[Power::GERMANY].push_back(Order("A MUN S F KIE - BER"));
  orders[Power::ENGLAND].push_back(Order("F KIE - BER"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.E.4. TEST CASE, NON-DISLODGED LOSER HAS STILL EFFECT
TEST_F(DATCTest, Test6E4) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HOL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HEL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::SKA);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::BEL);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::EDI);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::YOR);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NWG);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::KIE);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::RUH);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("F HOL - NTH"));
  orders[Power::GERMANY].push_back(Order("F HEL S F HOL - NTH"));
  orders[Power::GERMANY].push_back(Order("F SKA S F HOL - NTH"));
  orders[Power::FRANCE].push_back(Order("F NTH - HOL"));
  orders[Power::FRANCE].push_back(Order("F BEL S F NTH - HOL"));
  orders[Power::ENGLAND].push_back(Order("F EDI S F NWG - NTH"));
  orders[Power::ENGLAND].push_back(Order("F YOR S F NWG - NTH"));
  orders[Power::ENGLAND].push_back(Order("F NWG - NTH"));
  orders[Power::AUSTRIA].push_back(Order("A KIE S A RUH - HOL"));
  orders[Power::AUSTRIA].push_back(Order("A RUH - HOL"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect failure: A RUH - HOL
  EXPECT_FALSE(state.get_unit(Loc::RUH).power ==
                   next.get_unit(Loc::HOL).power &&
               state.get_unit(Loc::RUH).type == next.get_unit(Loc::HOL).type);
}

// 6.E.5. TEST CASE, LOSER DISLODGED BY ANOTHER ARMY HAS STILL EFFECT
TEST_F(DATCTest, Test6E5) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HOL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HEL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::SKA);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::BEL);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::EDI);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::YOR);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NWG);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::LON);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::KIE);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::RUH);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("F HOL - NTH"));
  orders[Power::GERMANY].push_back(Order("F HEL S F HOL - NTH"));
  orders[Power::GERMANY].push_back(Order("F SKA S F HOL - NTH"));
  orders[Power::FRANCE].push_back(Order("F NTH - HOL"));
  orders[Power::FRANCE].push_back(Order("F BEL S F NTH - HOL"));
  orders[Power::ENGLAND].push_back(Order("F EDI S F NWG - NTH"));
  orders[Power::ENGLAND].push_back(Order("F YOR S F NWG - NTH"));
  orders[Power::ENGLAND].push_back(Order("F NWG - NTH"));
  orders[Power::ENGLAND].push_back(Order("F LON S F NWG - NTH"));
  orders[Power::AUSTRIA].push_back(Order("A KIE S A RUH - HOL"));
  orders[Power::AUSTRIA].push_back(Order("A RUH - HOL"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect failure: A RUH - HOL
  EXPECT_FALSE(state.get_unit(Loc::RUH).power ==
                   next.get_unit(Loc::HOL).power &&
               state.get_unit(Loc::RUH).type == next.get_unit(Loc::HOL).type);
  // expect HOL not dislodged
  EXPECT_TRUE(state.get_unit(Loc::HOL).power == next.get_unit(Loc::HOL).power &&
              state.get_unit(Loc::HOL).type == next.get_unit(Loc::HOL).type);
  if (next.get_phase().phase_type == 'R') {
    EXPECT_THAT(next_orderable_locs, testing::Not(testing::Contains(Loc::HOL)));
  }
}

// 6.E.6. TEST CASE, NOT DISLODGE BECAUSE OF OWN SUPPORT HAS STILL EFFECT
TEST_F(DATCTest, Test6E6) {
  GameState state;
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HOL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HEL);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::BEL);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::KIE);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::RUH);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::GERMANY].push_back(Order("F HOL - NTH"));
  orders[Power::GERMANY].push_back(Order("F HEL S F HOL - NTH"));
  orders[Power::FRANCE].push_back(Order("F NTH - HOL"));
  orders[Power::FRANCE].push_back(Order("F BEL S F NTH - HOL"));
  orders[Power::FRANCE].push_back(Order("F ENG S F HOL - NTH"));
  orders[Power::AUSTRIA].push_back(Order("A KIE S A RUH - HOL"));
  orders[Power::AUSTRIA].push_back(Order("A RUH - HOL"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect failure: A RUH - HOL
  EXPECT_FALSE(state.get_unit(Loc::RUH).power ==
                   next.get_unit(Loc::HOL).power &&
               state.get_unit(Loc::RUH).type == next.get_unit(Loc::HOL).type);
}

// 6.E.7. TEST CASE, NO SELF DISLODGEMENT WITH BELEAGUERED GARRISON
TEST_F(DATCTest, Test6E7) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::YOR);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HOL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HEL);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::SKA);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::NWY);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F NTH H"));
  orders[Power::ENGLAND].push_back(Order("F YOR S F NWY - NTH"));
  orders[Power::GERMANY].push_back(Order("F HOL S F HEL - NTH"));
  orders[Power::GERMANY].push_back(Order("F HEL - NTH"));
  orders[Power::RUSSIA].push_back(Order("F SKA S F NWY - NTH"));
  orders[Power::RUSSIA].push_back(Order("F NWY - NTH"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect NTH not dislodged
  EXPECT_TRUE(state.get_unit(Loc::NTH).power == next.get_unit(Loc::NTH).power &&
              state.get_unit(Loc::NTH).type == next.get_unit(Loc::NTH).type);
  if (next.get_phase().phase_type == 'R') {
    EXPECT_THAT(next_orderable_locs, testing::Not(testing::Contains(Loc::NTH)));
  }
}

// 6.E.8. TEST CASE, NO SELF DISLODGEMENT WITH BELEAGUERED GARRISON AND HEAD TO
// HEAD BATTLE
TEST_F(DATCTest, Test6E8) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::YOR);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HOL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HEL);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::SKA);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::NWY);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F NTH - NWY"));
  orders[Power::ENGLAND].push_back(Order("F YOR S F NWY - NTH"));
  orders[Power::GERMANY].push_back(Order("F HOL S F HEL - NTH"));
  orders[Power::GERMANY].push_back(Order("F HEL - NTH"));
  orders[Power::RUSSIA].push_back(Order("F SKA S F NWY - NTH"));
  orders[Power::RUSSIA].push_back(Order("F NWY - NTH"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.E.9. TEST CASE, ALMOST SELF DISLODGEMENT WITH BELEAGUERED GARRISON
TEST_F(DATCTest, Test6E9) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::YOR);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HOL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HEL);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::SKA);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::NWY);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F NTH - NWG"));
  orders[Power::ENGLAND].push_back(Order("F YOR S F NWY - NTH"));
  orders[Power::GERMANY].push_back(Order("F HOL S F HEL - NTH"));
  orders[Power::GERMANY].push_back(Order("F HEL - NTH"));
  orders[Power::RUSSIA].push_back(Order("F SKA S F NWY - NTH"));
  orders[Power::RUSSIA].push_back(Order("F NWY - NTH"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: F NTH - NWG
  EXPECT_TRUE(state.get_unit(Loc::NTH).power == next.get_unit(Loc::NWG).power &&
              state.get_unit(Loc::NTH).type == next.get_unit(Loc::NWG).type);
  // expect success: F NWY - NTH
  EXPECT_TRUE(state.get_unit(Loc::NWY).power == next.get_unit(Loc::NTH).power &&
              state.get_unit(Loc::NWY).type == next.get_unit(Loc::NTH).type);
}

// 6.E.10. TEST CASE, ALMOST CIRCULAR MOVEMENT WITH NO SELF DISLODGEMENT WITH
// BELEAGUERED GARRISON
TEST_F(DATCTest, Test6E10) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::YOR);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HOL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HEL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::DEN);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::SKA);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::NWY);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F NTH - DEN"));
  orders[Power::ENGLAND].push_back(Order("F YOR S F NWY - NTH"));
  orders[Power::GERMANY].push_back(Order("F HOL S F HEL - NTH"));
  orders[Power::GERMANY].push_back(Order("F HEL - NTH"));
  orders[Power::GERMANY].push_back(Order("F DEN - HEL"));
  orders[Power::RUSSIA].push_back(Order("F SKA S F NWY - NTH"));
  orders[Power::RUSSIA].push_back(Order("F NWY - NTH"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.E.11. TEST CASE, NO SELF DISLODGEMENT WITH BELEAGUERED GARRISON, UNIT SWAP
// WITH ADJACENT CONVOYING AND TWO COASTS
TEST_F(DATCTest, Test6E11) {
  GameState state;
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::SPA);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::MAO);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::LYO);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::MAR);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::GAS);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::POR);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::WES);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::FRANCE].push_back(Order("A SPA - POR VIA"));
  orders[Power::FRANCE].push_back(Order("F MAO C A SPA - POR"));
  orders[Power::FRANCE].push_back(Order("F LYO S F POR - SPA/NC"));
  orders[Power::GERMANY].push_back(Order("A MAR S A GAS - SPA"));
  orders[Power::GERMANY].push_back(Order("A GAS - SPA"));
  orders[Power::ITALY].push_back(Order("F POR - SPA/NC"));
  orders[Power::ITALY].push_back(Order("F WES S F POR - SPA/NC"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A SPA - POR VIA
  EXPECT_TRUE(state.get_unit(Loc::SPA).power == next.get_unit(Loc::POR).power &&
              state.get_unit(Loc::SPA).type == next.get_unit(Loc::POR).type);
  // expect success: F POR - SPA/NC
  EXPECT_TRUE(state.get_unit(Loc::POR).power ==
                  next.get_unit(Loc::SPA_NC).power &&
              state.get_unit(Loc::POR).type == next.get_unit(Loc::SPA_NC).type);
}

// 6.E.12. TEST CASE, SUPPORT ON ATTACK ON OWN UNIT CAN BE USED FOR OTHER MEANS
TEST_F(DATCTest, Test6E12) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::BUD);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::SER);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::VIE);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::GAL);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::RUM);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("A BUD - RUM"));
  orders[Power::AUSTRIA].push_back(Order("A SER S A VIE - BUD"));
  orders[Power::ITALY].push_back(Order("A VIE - BUD"));
  orders[Power::RUSSIA].push_back(Order("A GAL - BUD"));
  orders[Power::RUSSIA].push_back(Order("A RUM S A GAL - BUD"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.E.13. TEST CASE, THREE WAY BELEAGUERED GARRISON
TEST_F(DATCTest, Test6E13) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::EDI);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::YOR);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::BEL);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::NWG);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::NWY);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F EDI S F YOR - NTH"));
  orders[Power::ENGLAND].push_back(Order("F YOR - NTH"));
  orders[Power::FRANCE].push_back(Order("F BEL - NTH"));
  orders[Power::FRANCE].push_back(Order("F ENG S F BEL - NTH"));
  orders[Power::GERMANY].push_back(Order("F NTH H"));
  orders[Power::RUSSIA].push_back(Order("F NWG - NTH"));
  orders[Power::RUSSIA].push_back(Order("F NWY S F NWG - NTH"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.E.14. TEST CASE, ILLEGAL HEAD TO HEAD BATTLE CAN STILL DEFEND
TEST_F(DATCTest, Test6E14) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LVP);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::EDI);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("A LVP - EDI"));
  orders[Power::RUSSIA].push_back(Order("F EDI - LVP"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.E.15. TEST CASE, THE FRIENDLY HEAD TO HEAD BATTLE
TEST_F(DATCTest, Test6E15) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::HOL);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::RUH);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::KIE);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::MUN);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::SIL);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BER);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::DEN);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HEL);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::BAL);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::PRU);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F HOL S A RUH - KIE"));
  orders[Power::ENGLAND].push_back(Order("A RUH - KIE"));
  orders[Power::FRANCE].push_back(Order("A KIE - BER"));
  orders[Power::FRANCE].push_back(Order("A MUN S A KIE - BER"));
  orders[Power::FRANCE].push_back(Order("A SIL S A KIE - BER"));
  orders[Power::GERMANY].push_back(Order("A BER - KIE"));
  orders[Power::GERMANY].push_back(Order("F DEN S A BER - KIE"));
  orders[Power::GERMANY].push_back(Order("F HEL S A BER - KIE"));
  orders[Power::RUSSIA].push_back(Order("F BAL S A PRU - BER"));
  orders[Power::RUSSIA].push_back(Order("A PRU - BER"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.F.1. TEST CASE, NO CONVOY IN COASTAL AREAS
TEST_F(DATCTest, Test6F1) {
  GameState state;
  state.set_unit(Power::TURKEY, UnitType::ARMY, Loc::GRE);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::AEG);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::CON);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::BLA);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::TURKEY].push_back(Order("A GRE - SEV"));
  orders[Power::TURKEY].push_back(Order("F AEG C A GRE - SEV"));
  orders[Power::TURKEY].push_back(Order("F CON C A GRE - SEV"));
  orders[Power::TURKEY].push_back(Order("F BLA C A GRE - SEV"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect failure: A GRE - SEV
  EXPECT_FALSE(state.get_unit(Loc::GRE).power ==
                   next.get_unit(Loc::SEV).power &&
               state.get_unit(Loc::GRE).type == next.get_unit(Loc::SEV).type);
}

// 6.F.2. TEST CASE, AN ARMY BEING CONVOYED CAN BOUNCE AS NORMAL
TEST_F(DATCTest, Test6F2) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LON);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::PAR);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F ENG C A LON - BRE"));
  orders[Power::ENGLAND].push_back(Order("A LON - BRE"));
  orders[Power::FRANCE].push_back(Order("A PAR - BRE"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.F.3. TEST CASE, AN ARMY BEING CONVOYED CAN RECEIVE SUPPORT
TEST_F(DATCTest, Test6F3) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LON);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::MAO);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::PAR);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F ENG C A LON - BRE"));
  orders[Power::ENGLAND].push_back(Order("A LON - BRE"));
  orders[Power::ENGLAND].push_back(Order("F MAO S A LON - BRE"));
  orders[Power::FRANCE].push_back(Order("A PAR - BRE"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A LON - BRE
  EXPECT_TRUE(state.get_unit(Loc::LON).power == next.get_unit(Loc::BRE).power &&
              state.get_unit(Loc::LON).type == next.get_unit(Loc::BRE).type);
  // expect failure: A PAR - BRE
  EXPECT_FALSE(state.get_unit(Loc::PAR).power ==
                   next.get_unit(Loc::BRE).power &&
               state.get_unit(Loc::PAR).type == next.get_unit(Loc::BRE).type);
}

// 6.F.4. TEST CASE, AN ATTACKED CONVOY IS NOT DISRUPTED
TEST_F(DATCTest, Test6F4) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LON);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::SKA);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F NTH C A LON - HOL"));
  orders[Power::ENGLAND].push_back(Order("A LON - HOL"));
  orders[Power::GERMANY].push_back(Order("F SKA - NTH"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A LON - HOL
  EXPECT_TRUE(state.get_unit(Loc::LON).power == next.get_unit(Loc::HOL).power &&
              state.get_unit(Loc::LON).type == next.get_unit(Loc::HOL).type);
}

// 6.F.5. TEST CASE, A BELEAGUERED CONVOY IS NOT DISRUPTED
TEST_F(DATCTest, Test6F5) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LON);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::BEL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::SKA);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::DEN);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F NTH C A LON - HOL"));
  orders[Power::ENGLAND].push_back(Order("A LON - HOL"));
  orders[Power::FRANCE].push_back(Order("F ENG - NTH"));
  orders[Power::FRANCE].push_back(Order("F BEL S F ENG - NTH"));
  orders[Power::GERMANY].push_back(Order("F SKA - NTH"));
  orders[Power::GERMANY].push_back(Order("F DEN S F SKA - NTH"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A LON - HOL
  EXPECT_TRUE(state.get_unit(Loc::LON).power == next.get_unit(Loc::HOL).power &&
              state.get_unit(Loc::LON).type == next.get_unit(Loc::HOL).type);
}

// 6.F.6. TEST CASE, DISLODGED CONVOY DOES NOT CUT SUPPORT
TEST_F(DATCTest, Test6F6) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LON);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::HOL);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BEL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HEL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::SKA);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::PIC);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::BUR);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F NTH C A LON - HOL"));
  orders[Power::ENGLAND].push_back(Order("A LON - HOL"));
  orders[Power::GERMANY].push_back(Order("A HOL S A BEL"));
  orders[Power::GERMANY].push_back(Order("A BEL S A HOL"));
  orders[Power::GERMANY].push_back(Order("F HEL S F SKA - NTH"));
  orders[Power::GERMANY].push_back(Order("F SKA - NTH"));
  orders[Power::FRANCE].push_back(Order("A PIC - BEL"));
  orders[Power::FRANCE].push_back(Order("A BUR S A PIC - BEL"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect BEL not dislodged
  EXPECT_TRUE(state.get_unit(Loc::BEL).power == next.get_unit(Loc::BEL).power &&
              state.get_unit(Loc::BEL).type == next.get_unit(Loc::BEL).type);
  if (next.get_phase().phase_type == 'R') {
    EXPECT_THAT(next_orderable_locs, testing::Not(testing::Contains(Loc::BEL)));
  }
}

// 6.F.8. TEST CASE, DISLODGED CONVOY DOES NOT CAUSE A BOUNCE
TEST_F(DATCTest, Test6F8) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LON);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HEL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::SKA);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BEL);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F NTH C A LON - HOL"));
  orders[Power::ENGLAND].push_back(Order("A LON - HOL"));
  orders[Power::GERMANY].push_back(Order("F HEL S F SKA - NTH"));
  orders[Power::GERMANY].push_back(Order("F SKA - NTH"));
  orders[Power::GERMANY].push_back(Order("A BEL - HOL"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A BEL - HOL
  EXPECT_TRUE(state.get_unit(Loc::BEL).power == next.get_unit(Loc::HOL).power &&
              state.get_unit(Loc::BEL).type == next.get_unit(Loc::HOL).type);
}

// 6.F.9. TEST CASE, DISLODGE OF MULTI-ROUTE CONVOY
TEST_F(DATCTest, Test6F9) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LON);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::BRE);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::MAO);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F ENG C A LON - BEL"));
  orders[Power::ENGLAND].push_back(Order("F NTH C A LON - BEL"));
  orders[Power::ENGLAND].push_back(Order("A LON - BEL"));
  orders[Power::FRANCE].push_back(Order("F BRE S F MAO - ENG"));
  orders[Power::FRANCE].push_back(Order("F MAO - ENG"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A LON - BEL
  EXPECT_TRUE(state.get_unit(Loc::LON).power == next.get_unit(Loc::BEL).power &&
              state.get_unit(Loc::LON).type == next.get_unit(Loc::BEL).type);
}

// 6.F.10. TEST CASE, DISLODGE OF MULTI-ROUTE CONVOY WITH FOREIGN FLEET
TEST_F(DATCTest, Test6F10) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LON);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::BRE);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::MAO);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F NTH C A LON - BEL"));
  orders[Power::ENGLAND].push_back(Order("A LON - BEL"));
  orders[Power::GERMANY].push_back(Order("F ENG C A LON - BEL"));
  orders[Power::FRANCE].push_back(Order("F BRE S F MAO - ENG"));
  orders[Power::FRANCE].push_back(Order("F MAO - ENG"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A LON - BEL
  EXPECT_TRUE(state.get_unit(Loc::LON).power == next.get_unit(Loc::BEL).power &&
              state.get_unit(Loc::LON).type == next.get_unit(Loc::BEL).type);
}

// 6.F.11. TEST CASE, DISLODGE OF MULTI-ROUTE CONVOY WITH ONLY FOREIGN FLEETS
TEST_F(DATCTest, Test6F11) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LON);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::BRE);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::MAO);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("A LON - BEL"));
  orders[Power::GERMANY].push_back(Order("F ENG C A LON - BEL"));
  orders[Power::RUSSIA].push_back(Order("F NTH C A LON - BEL"));
  orders[Power::FRANCE].push_back(Order("F BRE S F MAO - ENG"));
  orders[Power::FRANCE].push_back(Order("F MAO - ENG"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A LON - BEL
  EXPECT_TRUE(state.get_unit(Loc::LON).power == next.get_unit(Loc::BEL).power &&
              state.get_unit(Loc::LON).type == next.get_unit(Loc::BEL).type);
}

// 6.F.12. TEST CASE, DISLODGED CONVOYING FLEET NOT ON ROUTE
TEST_F(DATCTest, Test6F12) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LON);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::IRI);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::NAO);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::MAO);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F ENG C A LON - BEL"));
  orders[Power::ENGLAND].push_back(Order("A LON - BEL"));
  orders[Power::ENGLAND].push_back(Order("F IRI C A LON - BEL"));
  orders[Power::FRANCE].push_back(Order("F NAO S F MAO - IRI"));
  orders[Power::FRANCE].push_back(Order("F MAO - IRI"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A LON - BEL
  EXPECT_TRUE(state.get_unit(Loc::LON).power == next.get_unit(Loc::BEL).power &&
              state.get_unit(Loc::LON).type == next.get_unit(Loc::BEL).type);
}

// 6.F.13. TEST CASE, THE UNWANTED ALTERNATIVE
TEST_F(DATCTest, Test6F13) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LON);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HOL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::DEN);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("A LON - BEL"));
  orders[Power::ENGLAND].push_back(Order("F NTH C A LON - BEL"));
  orders[Power::FRANCE].push_back(Order("F ENG C A LON - BEL"));
  orders[Power::GERMANY].push_back(Order("F HOL S F DEN - NTH"));
  orders[Power::GERMANY].push_back(Order("F DEN - NTH"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: A LON - BEL
  EXPECT_TRUE(state.get_unit(Loc::LON).power == next.get_unit(Loc::BEL).power &&
              state.get_unit(Loc::LON).type == next.get_unit(Loc::BEL).type);
  // expect NTH dislodged
  EXPECT_FALSE(state.get_unit(Loc::NTH).power ==
                   next.get_unit(Loc::NTH).power &&
               state.get_unit(Loc::NTH).type == next.get_unit(Loc::NTH).type);
}

// 6.F.14. TEST CASE, SIMPLE CONVOY PARADOX
TEST_F(DATCTest, Test6F14) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::LON);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::WAL);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::BRE);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::ENG);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F LON S F WAL - ENG"));
  orders[Power::ENGLAND].push_back(Order("F WAL - ENG"));
  orders[Power::FRANCE].push_back(Order("A BRE - LON"));
  orders[Power::FRANCE].push_back(Order("F ENG C A BRE - LON"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect ENG dislodged
  EXPECT_FALSE(state.get_unit(Loc::ENG).power ==
                   next.get_unit(Loc::ENG).power &&
               state.get_unit(Loc::ENG).type == next.get_unit(Loc::ENG).type);
}

// 6.F.15. TEST CASE, SIMPLE CONVOY PARADOX WITH ADDITIONAL CONVOY
TEST_F(DATCTest, Test6F15) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::LON);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::WAL);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::BRE);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::IRI);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::MAO);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::NAF);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F LON S F WAL - ENG"));
  orders[Power::ENGLAND].push_back(Order("F WAL - ENG"));
  orders[Power::FRANCE].push_back(Order("A BRE - LON"));
  orders[Power::FRANCE].push_back(Order("F ENG C A BRE - LON"));
  orders[Power::ITALY].push_back(Order("F IRI C A NAF - WAL"));
  orders[Power::ITALY].push_back(Order("F MAO C A NAF - WAL"));
  orders[Power::ITALY].push_back(Order("A NAF - WAL"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: F WAL - ENG
  EXPECT_TRUE(state.get_unit(Loc::WAL).power == next.get_unit(Loc::ENG).power &&
              state.get_unit(Loc::WAL).type == next.get_unit(Loc::ENG).type);
  // expect success: A NAF - WAL
  EXPECT_TRUE(state.get_unit(Loc::NAF).power == next.get_unit(Loc::WAL).power &&
              state.get_unit(Loc::NAF).type == next.get_unit(Loc::WAL).type);
}

// 6.F.16. TEST CASE, PANDIN'S PARADOX
TEST_F(DATCTest, Test6F16) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::LON);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::WAL);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::BRE);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::BEL);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F LON S F WAL - ENG"));
  orders[Power::ENGLAND].push_back(Order("F WAL - ENG"));
  orders[Power::FRANCE].push_back(Order("A BRE - LON"));
  orders[Power::FRANCE].push_back(Order("F ENG C A BRE - LON"));
  orders[Power::GERMANY].push_back(Order("F NTH S F BEL - ENG"));
  orders[Power::GERMANY].push_back(Order("F BEL - ENG"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect no unit moves
  EXPECT_THAT(next.get_units(), testing::ContainerEq(state.get_units()));
}

// 6.F.17. TEST CASE, PANDIN'S EXTENDED PARADOX
TEST_F(DATCTest, Test6F17) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::LON);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::WAL);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::BRE);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::YOR);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::BEL);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F LON S F WAL - ENG"));
  orders[Power::ENGLAND].push_back(Order("F WAL - ENG"));
  orders[Power::FRANCE].push_back(Order("A BRE - LON"));
  orders[Power::FRANCE].push_back(Order("F ENG C A BRE - LON"));
  orders[Power::FRANCE].push_back(Order("F YOR S A BRE - LON"));
  orders[Power::GERMANY].push_back(Order("F NTH S F BEL - ENG"));
  orders[Power::GERMANY].push_back(Order("F BEL - ENG"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect LON not dislodged
  EXPECT_TRUE(state.get_unit(Loc::LON).power == next.get_unit(Loc::LON).power &&
              state.get_unit(Loc::LON).type == next.get_unit(Loc::LON).type);
  if (next.get_phase().phase_type == 'R') {
    EXPECT_THAT(next_orderable_locs, testing::Not(testing::Contains(Loc::LON)));
  }
  // expect ENG not dislodged
  EXPECT_TRUE(state.get_unit(Loc::ENG).power == next.get_unit(Loc::ENG).power &&
              state.get_unit(Loc::ENG).type == next.get_unit(Loc::ENG).type);
  if (next.get_phase().phase_type == 'R') {
    EXPECT_THAT(next_orderable_locs, testing::Not(testing::Contains(Loc::ENG)));
  }
}

// 6.F.18. TEST CASE, BETRAYAL PARADOX
TEST_F(DATCTest, Test6F18) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LON);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::BEL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::HEL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::SKA);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F NTH C A LON - BEL"));
  orders[Power::ENGLAND].push_back(Order("A LON - BEL"));
  orders[Power::ENGLAND].push_back(Order("F ENG S A LON - BEL"));
  orders[Power::FRANCE].push_back(Order("F BEL S F NTH"));
  orders[Power::GERMANY].push_back(Order("F HEL S F SKA - NTH"));
  orders[Power::GERMANY].push_back(Order("F SKA - NTH"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect failure: A LON - BEL
  EXPECT_FALSE(state.get_unit(Loc::LON).power ==
                   next.get_unit(Loc::BEL).power &&
               state.get_unit(Loc::LON).type == next.get_unit(Loc::BEL).type);
  // expect NTH not dislodged
  EXPECT_TRUE(state.get_unit(Loc::NTH).power == next.get_unit(Loc::NTH).power &&
              state.get_unit(Loc::NTH).type == next.get_unit(Loc::NTH).type);
  if (next.get_phase().phase_type == 'R') {
    EXPECT_THAT(next_orderable_locs, testing::Not(testing::Contains(Loc::NTH)));
  }
}

// 6.F.19. TEST CASE, MULTI-ROUTE CONVOY DISRUPTION PARADOX
TEST_F(DATCTest, Test6F19) {
  GameState state;
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::TUN);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::TYS);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::ION);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::NAP);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::ROM);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::FRANCE].push_back(Order("A TUN - NAP"));
  orders[Power::FRANCE].push_back(Order("F TYS C A TUN - NAP"));
  orders[Power::FRANCE].push_back(Order("F ION C A TUN - NAP"));
  orders[Power::ITALY].push_back(Order("F NAP S F ROM - TYS"));
  orders[Power::ITALY].push_back(Order("F ROM - TYS"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect TYR not dislodged
  EXPECT_TRUE(state.get_unit(Loc::TYR).power == next.get_unit(Loc::TYR).power &&
              state.get_unit(Loc::TYR).type == next.get_unit(Loc::TYR).type);
  if (next.get_phase().phase_type == 'R') {
    EXPECT_THAT(next_orderable_locs, testing::Not(testing::Contains(Loc::TYR)));
  }
}

// 6.F.20. TEST CASE, UNWANTED MULTI-ROUTE CONVOY PARADOX
TEST_F(DATCTest, Test6F20) {
  GameState state;
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::TUN);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::TYS);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::NAP);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::ION);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::AEG);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::EAS);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::FRANCE].push_back(Order("A TUN - NAP"));
  orders[Power::FRANCE].push_back(Order("F TYS C A TUN - NAP"));
  orders[Power::ITALY].push_back(Order("F NAP S F ION"));
  orders[Power::ITALY].push_back(Order("F ION C A TUN - NAP"));
  orders[Power::TURKEY].push_back(Order("F AEG S F EAS - ION"));
  orders[Power::TURKEY].push_back(Order("F EAS - ION"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect ION dislodged
  EXPECT_FALSE(state.get_unit(Loc::ION).power ==
                   next.get_unit(Loc::ION).power &&
               state.get_unit(Loc::ION).type == next.get_unit(Loc::ION).type);
}

// 6.F.21. TEST CASE, DAD'S ARMY CONVOY
TEST_F(DATCTest, Test6F21) {
  GameState state;
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::EDI);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::NWG);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::NWY);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::IRI);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::MAO);
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LVP);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NAO);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::CLY);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::RUSSIA].push_back(Order("A EDI S A NWY - CLY"));
  orders[Power::RUSSIA].push_back(Order("F NWG C A NWY - CLY"));
  orders[Power::RUSSIA].push_back(Order("A NWY - CLY"));
  orders[Power::FRANCE].push_back(Order("F IRI S F MAO - NAO"));
  orders[Power::FRANCE].push_back(Order("F MAO - NAO"));
  orders[Power::ENGLAND].push_back(Order("A LVP - CLY VIA"));
  orders[Power::ENGLAND].push_back(Order("F NAO C A LVP - CLY"));
  orders[Power::ENGLAND].push_back(Order("F CLY S F NAO"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect NAO dislodged
  EXPECT_FALSE(state.get_unit(Loc::NAO).power ==
                   next.get_unit(Loc::NAO).power &&
               state.get_unit(Loc::NAO).type == next.get_unit(Loc::NAO).type);
}

// 6.F.22. TEST CASE, SECOND ORDER PARADOX WITH TWO RESOLUTIONS
TEST_F(DATCTest, Test6F22) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::EDI);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::LON);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::BRE);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::BEL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::PIC);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::NWY);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::NTH);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F EDI - NTH"));
  orders[Power::ENGLAND].push_back(Order("F LON S F EDI - NTH"));
  orders[Power::FRANCE].push_back(Order("A BRE - LON"));
  orders[Power::FRANCE].push_back(Order("F ENG C A BRE - LON"));
  orders[Power::GERMANY].push_back(Order("F BEL S F PIC - ENG"));
  orders[Power::GERMANY].push_back(Order("F PIC - ENG"));
  orders[Power::RUSSIA].push_back(Order("A NWY - BEL"));
  orders[Power::RUSSIA].push_back(Order("F NTH C A NWY - BEL"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect success: F PIC - ENG
  EXPECT_TRUE(state.get_unit(Loc::PIC).power == next.get_unit(Loc::ENG).power &&
              state.get_unit(Loc::PIC).type == next.get_unit(Loc::ENG).type);
  // expect success: F EDI - NTH
  EXPECT_TRUE(state.get_unit(Loc::EDI).power == next.get_unit(Loc::NTH).power &&
              state.get_unit(Loc::EDI).type == next.get_unit(Loc::NTH).type);
  // expect NTH dislodged
  EXPECT_FALSE(state.get_unit(Loc::NTH).power ==
                   next.get_unit(Loc::NTH).power &&
               state.get_unit(Loc::NTH).type == next.get_unit(Loc::NTH).type);
}

// 6.F.23. TEST CASE, SECOND ORDER PARADOX WITH TWO EXCLUSIVE CONVOYS
TEST_F(DATCTest, Test6F23) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::EDI);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::YOR);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::BRE);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::BEL);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::LON);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::MAO);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::IRI);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::NWY);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::NTH);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F EDI - NTH"));
  orders[Power::ENGLAND].push_back(Order("F YOR S F EDI - NTH"));
  orders[Power::FRANCE].push_back(Order("A BRE - LON"));
  orders[Power::FRANCE].push_back(Order("F ENG C A BRE - LON"));
  orders[Power::GERMANY].push_back(Order("F BEL S F ENG"));
  orders[Power::GERMANY].push_back(Order("F LON S F NTH"));
  orders[Power::ITALY].push_back(Order("F MAO - ENG"));
  orders[Power::ITALY].push_back(Order("F IRI S F MAO - ENG"));
  orders[Power::RUSSIA].push_back(Order("A NWY - BEL"));
  orders[Power::RUSSIA].push_back(Order("F NTH C A NWY - BEL"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect failure: A NWY - BEL
  EXPECT_FALSE(state.get_unit(Loc::NWY).power ==
                   next.get_unit(Loc::BEL).power &&
               state.get_unit(Loc::NWY).type == next.get_unit(Loc::BEL).type);
  // expect failure: A BRE - LON
  EXPECT_FALSE(state.get_unit(Loc::BRE).power ==
                   next.get_unit(Loc::LON).power &&
               state.get_unit(Loc::BRE).type == next.get_unit(Loc::LON).type);
}

// 6.F.24. TEST CASE, SECOND ORDER PARADOX WITH NO RESOLUTION
TEST_F(DATCTest, Test6F24) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::EDI);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::LON);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::IRI);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::MAO);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::BRE);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::BEL);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::NWY);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::NTH);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F EDI - NTH"));
  orders[Power::ENGLAND].push_back(Order("F LON S F EDI - NTH"));
  orders[Power::ENGLAND].push_back(Order("F IRI - ENG"));
  orders[Power::ENGLAND].push_back(Order("F MAO S F IRI - ENG"));
  orders[Power::FRANCE].push_back(Order("A BRE - LON"));
  orders[Power::FRANCE].push_back(Order("F ENG C A BRE - LON"));
  orders[Power::FRANCE].push_back(Order("F BEL S F ENG"));
  orders[Power::RUSSIA].push_back(Order("A NWY - BEL"));
  orders[Power::RUSSIA].push_back(Order("F NTH C A NWY - BEL"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect failure: A BRE - LON
  EXPECT_FALSE(state.get_unit(Loc::BRE).power ==
                   next.get_unit(Loc::LON).power &&
               state.get_unit(Loc::BRE).type == next.get_unit(Loc::LON).type);
  // expect failure: A NWY - BEL
  EXPECT_FALSE(state.get_unit(Loc::NWY).power ==
                   next.get_unit(Loc::BEL).power &&
               state.get_unit(Loc::NWY).type == next.get_unit(Loc::BEL).type);
}

// 6.H.5. TEST CASE, A UNIT MAY NOT RETREAT TO THE AREA FROM WHICH IT IS
// ATTACKED
TEST_F(DATCTest, Test6H5) {
  GameState state;
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::CON);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::BLA);
  state.set_unit(Power::TURKEY, UnitType::FLEET, Loc::ANK);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::RUSSIA].push_back(Order("F CON S F BLA - ANK"));
  orders[Power::RUSSIA].push_back(Order("F BLA - ANK"));
  orders[Power::TURKEY].push_back(Order("F ANK H"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect ANK dislodged
  EXPECT_FALSE(state.get_unit(Loc::ANK).power ==
                   next.get_unit(Loc::ANK).power &&
               state.get_unit(Loc::ANK).type == next.get_unit(Loc::ANK).type);
  // expect retreat order not possible: F ANK R BLA
  if (next.get_phase().phase_type == 'R') {
    EXPECT_THAT(next_possible_orders[Loc::ANK],
                testing::Not(testing::Contains(Order("F ANK R BLA"))));
  }
}

// 6.H.6. TEST CASE, UNIT MAY NOT RETREAT TO A CONTESTED AREA
TEST_F(DATCTest, Test6H6) {
  GameState state;
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::BUD);
  state.set_unit(Power::AUSTRIA, UnitType::ARMY, Loc::TRI);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::MUN);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::SIL);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::VIE);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::AUSTRIA].push_back(Order("A BUD S A TRI - VIE"));
  orders[Power::AUSTRIA].push_back(Order("A TRI - VIE"));
  orders[Power::GERMANY].push_back(Order("A MUN - BOH"));
  orders[Power::GERMANY].push_back(Order("A SIL - BOH"));
  orders[Power::ITALY].push_back(Order("A VIE H"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect VIE dislodged
  EXPECT_FALSE(state.get_unit(Loc::VIE).power ==
                   next.get_unit(Loc::VIE).power &&
               state.get_unit(Loc::VIE).type == next.get_unit(Loc::VIE).type);
  // expect retreat order not possible: A VIE R BOH
  if (next.get_phase().phase_type == 'R') {
    EXPECT_THAT(next_possible_orders[Loc::VIE],
                testing::Not(testing::Contains(Order("A VIE R BOH"))));
  }
}

// 6.H.9. TEST CASE, DISLODGED UNIT WILL NOT MAKE ATTACKERS AREA CONTESTED
TEST_F(DATCTest, Test6H9) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::HEL);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::DEN);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::BER);
  state.set_unit(Power::GERMANY, UnitType::FLEET, Loc::KIE);
  state.set_unit(Power::GERMANY, UnitType::ARMY, Loc::SIL);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::PRU);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F HEL - KIE"));
  orders[Power::ENGLAND].push_back(Order("F DEN S F HEL - KIE"));
  orders[Power::GERMANY].push_back(Order("A BER - PRU"));
  orders[Power::GERMANY].push_back(Order("F KIE H"));
  orders[Power::GERMANY].push_back(Order("A SIL S A BER - PRU"));
  orders[Power::RUSSIA].push_back(Order("A PRU - BER"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect retreat order possible: F KIE R BER
  EXPECT_EQ(next.get_phase().phase_type, 'R') << "Should be retreat phase";
  EXPECT_THAT(next_possible_orders[Loc::KIE],
              testing::Contains(Order("F KIE R BER")));
}

// 6.H.11. TEST CASE, RETREAT WHEN DISLODGED BY ADJACENT CONVOY
TEST_F(DATCTest, DISABLED_Test6H11) {
  GameState state;
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::GAS);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::BUR);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::MAO);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::WES);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::LYO);
  state.set_unit(Power::ITALY, UnitType::ARMY, Loc::MAR);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::FRANCE].push_back(Order("A GAS - MAR VIA"));
  orders[Power::FRANCE].push_back(Order("A BUR S A GAS - MAR"));
  orders[Power::FRANCE].push_back(Order("F MAO C A GAS - MAR"));
  orders[Power::FRANCE].push_back(Order("F WES C A GAS - MAR"));
  orders[Power::FRANCE].push_back(Order("F LYO C A GAS - MAR"));
  orders[Power::ITALY].push_back(Order("A MAR H"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect retreat order possible: A MAR R GAS
  EXPECT_EQ(next.get_phase().phase_type, 'R') << "Should be retreat phase";
  EXPECT_THAT(next_possible_orders[Loc::MAR],
              testing::Contains(Order("A MAR R GAS")));
}

// 6.H.12. TEST CASE, RETREAT WHEN DISLODGED BY ADJACENT CONVOY WHILE TRYING TO
// DO THE SAME
TEST_F(DATCTest, DISABLED_Test6H12) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::LVP);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::IRI);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::NTH);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::BRE);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::MAO);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::EDI);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::NWG);
  state.set_unit(Power::RUSSIA, UnitType::FLEET, Loc::NAO);
  state.set_unit(Power::RUSSIA, UnitType::ARMY, Loc::CLY);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("A LVP - EDI VIA"));
  orders[Power::ENGLAND].push_back(Order("F IRI C A LVP - EDI"));
  orders[Power::ENGLAND].push_back(Order("F ENG C A LVP - EDI"));
  orders[Power::ENGLAND].push_back(Order("F NTH C A LVP - EDI"));
  orders[Power::FRANCE].push_back(Order("F BRE - ENG"));
  orders[Power::FRANCE].push_back(Order("F MAO S F BRE - ENG"));
  orders[Power::RUSSIA].push_back(Order("A EDI - LVP VIA"));
  orders[Power::RUSSIA].push_back(Order("F NWG C A EDI - LVP"));
  orders[Power::RUSSIA].push_back(Order("F NAO C A EDI - LVP"));
  orders[Power::RUSSIA].push_back(Order("A CLY S A EDI - LVP"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect retreat order possible: A LVP R EDI
  EXPECT_EQ(next.get_phase().phase_type, 'R') << "Should be retreat phase";
  EXPECT_THAT(next_possible_orders[Loc::LVP],
              testing::Contains(Order("A LVP R EDI")));
}

// 6.H.13. TEST CASE, NO RETREAT WITH CONVOY IN MAIN PHASE
TEST_F(DATCTest, Test6H13) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::ARMY, Loc::PIC);
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::ENG);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::PAR);
  state.set_unit(Power::FRANCE, UnitType::ARMY, Loc::BRE);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("A PIC H"));
  orders[Power::ENGLAND].push_back(Order("F ENG C A PIC - LON"));
  orders[Power::FRANCE].push_back(Order("A PAR - PIC"));
  orders[Power::FRANCE].push_back(Order("A BRE S A PAR - PIC"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect PIC dislodged
  EXPECT_FALSE(state.get_unit(Loc::PIC).power ==
                   next.get_unit(Loc::PIC).power &&
               state.get_unit(Loc::PIC).type == next.get_unit(Loc::PIC).type);
  // expect retreat order not possible: A PIC R LON
  if (next.get_phase().phase_type == 'R') {
    EXPECT_THAT(next_possible_orders[Loc::PIC],
                testing::Not(testing::Contains(Order("A PIC R LON"))));
  }
}

// 6.H.15. TEST CASE, NO COASTAL CRAWL IN RETREAT
TEST_F(DATCTest, Test6H15) {
  GameState state;
  state.set_unit(Power::ENGLAND, UnitType::FLEET, Loc::POR);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::SPA_SC);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::MAO);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::ENGLAND].push_back(Order("F POR H"));
  orders[Power::FRANCE].push_back(Order("F SPA/SC - POR"));
  orders[Power::FRANCE].push_back(Order("F MAO S F SPA/SC - POR"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect POR dislodged
  EXPECT_FALSE(state.get_unit(Loc::POR).power ==
                   next.get_unit(Loc::POR).power &&
               state.get_unit(Loc::POR).type == next.get_unit(Loc::POR).type);
  // expect POR dislodged
  EXPECT_FALSE(state.get_unit(Loc::POR).power ==
                   next.get_unit(Loc::POR).power &&
               state.get_unit(Loc::POR).type == next.get_unit(Loc::POR).type);
}

// 6.H.16. TEST CASE, CONTESTED FOR BOTH COASTS
TEST_F(DATCTest, Test6H16) {
  GameState state;
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::MAO);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::GAS);
  state.set_unit(Power::FRANCE, UnitType::FLEET, Loc::WES);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::TUN);
  state.set_unit(Power::ITALY, UnitType::FLEET, Loc::TYS);

  for (auto it_loc_orders : state.get_all_possible_orders()) {
    LOG(INFO) << "ALL_POSSIBLE_ORDERS: " << loc_str(it_loc_orders.first);
    for (auto &order : it_loc_orders.second) {
      LOG(INFO) << "  " << order.to_string();
    }
  }
  std::unordered_map<Power, std::vector<Order>> orders;
  orders[Power::FRANCE].push_back(Order("F MAO - SPA/NC"));
  orders[Power::FRANCE].push_back(Order("F GAS - SPA/NC"));
  orders[Power::FRANCE].push_back(Order("F WES H"));
  orders[Power::ITALY].push_back(Order("F TUN S F TYS - WES"));
  orders[Power::ITALY].push_back(Order("F TYS - WES"));

  GameState next(state.process(orders));

  auto next_possible_orders(next.get_all_possible_orders());
  set<Loc> next_orderable_locs;
  for (auto &it : next.get_orderable_locations()) {
    for (Loc loc : it.second) {
      next_orderable_locs.insert(loc);
    }
  }

  // expect retreat order not possible: F WES R SPA/SC
  if (next.get_phase().phase_type == 'R') {
    EXPECT_THAT(next_possible_orders[Loc::WES],
                testing::Not(testing::Contains(Order("F WES R SPA/SC"))));
  }
}

} // namespace dipcc
