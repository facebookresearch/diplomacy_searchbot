import argparse
import json
import sys

from fairdiplomacy.game import Game
from fairdiplomacy.models.consts import LOCS, POWERS

parser = argparse.ArgumentParser()
parser.add_argument("game_json", default="/tmp/blah/13May_game1.json")
args = parser.parse_args()

game_json_safe = args.game_json.replace("/", "_").replace(".", "_")

HEADER = f"""
// This file is auto-generated by {__file__}
//
#include <algorithm>
#include <vector>
#include "../cc/game.h"
#include "../cc/hash.h"
#include "../cc/thirdparty/nlohmann/json.hpp"
#include "consts.h"
#include "utils.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

using namespace std;
using nlohmann::json;

namespace dipcc {{

class GameEquivalenceTest : public ::testing::Test {{}};

TEST_F(GameEquivalenceTest, Test_{game_json_safe}) {{

Game game;

"""

FOOTER = """
} // TEST_F
} // namespace dipcc
"""


def print_state_tests(state):
    print("{ // state tests:", state["name"])
    print("const json& j = game.get_state().to_json();")

    # phase
    print(f"""ASSERT_EQ(game.get_state().get_phase().to_string(), "{state['name']}");""")

    # units
    for power in POWERS:
        units = [u for u in state["units"].get(power, []) if not u.startswith("*")]
        units_literal = str(set(units)).replace("'", '"') if units else "{}"
        print(
            f"""set<string> units_{power} = j["units"].contains("{power}") ? set<string>(j["units"]["{power}"].begin(), j["units"]["{power}"].end()) : set<string>();"""
        )
        print(
            f"""for (auto it = units_{power}.begin() ; it != units_{power}.end() ;) {{""",
            f"""  if (it->substr(0, 1) == "*") {{ it = units_{power}.erase(it); }} else {{ ++it; }} }}""",
        )
        print(f"""set<string> units_{power}_exp{units_literal};""")
        print(f"""ASSERT_THAT(units_{power}, testing::ContainerEq(units_{power}_exp));""")

    # centers
    for power in POWERS:
        centers = state["centers"].get(power, [])
        centers_literal = str(set(centers)).replace("'", '"') if centers else "{}"
        print(
            f"""set<string> centers_{power} = j["centers"].contains("{power}") ? set<string>(j["centers"]["{power}"].begin(), j["centers"]["{power}"].end()) : set<string>();"""
        )
        print(f"""set<string> centers_{power}_exp{centers_literal};""")
        print(f"""ASSERT_THAT(centers_{power}, testing::ContainerEq(centers_{power}_exp));""")

    print("} // state tests:", state["name"])


def print_possible_orders_tests(game):
    print("\n// Check possible orders:", game.phase)
    print("{")
    print("auto all_possible_orders(game.get_all_possible_orders());")
    for loc, orders in game.get_all_possible_orders().items():
        if loc == "SWI":
            continue
        orders = [x for x in orders if x != "WAIVE"]
        if not any(order.split()[1] == loc for order in orders):
            # MILA's get_all_possible_orders() shows orders for STP/NC under
            # STP. We make assertions only about the precise unit loc.
            continue
        loc_safe = loc.replace("/", "_")
        print(f"std::set<Order> orders_{loc_safe}_exp;")
        for order in orders:
            print(f"""orders_{loc_safe}_exp.insert(Order("{order}"));""")
        print(
            f"std::set<Order> orders_{loc_safe}_got{{all_possible_orders[Loc::{loc_safe}].begin(), all_possible_orders[Loc::{loc_safe}].end()}};"
        )
        print(
            f"assert_possible_orders_eq(orders_{loc_safe}_got, orders_{loc_safe}_exp, loc_str(Loc::{loc_safe}));"
        )
        print()

    print("} // possible orders:", game.phase)


def print_orders_and_process(orders):
    print("\n// Submit orders")
    for power, x in orders.items():
        if not x:
            continue
        safe_orders = "{" + ", ".join(f'"{z}"' for z in x) + "}"
        print(f"""game.set_orders("{power}", {safe_orders});""")
    print("game.process();\n")


def process_py_game(game, orders):
    for k, v in orders.items():
        game.set_orders(k, v)
    game.process()


def compile_phase_list(j):
    return [
        {"name": name, "state": state, "orders": j["order_history"][name]}
        for name, state in j["state_history"].items()
    ]


if __name__ == "__main__":
    with open(args.game_json, "r") as f:
        j = json.loads(f.readlines()[-1])

    if j.get("map", "standard") != "standard":
        print("Skipping non-standard game:", args.game_json, file=sys.stderr)
        sys.exit(0)

    game = Game()

    print(HEADER)

    phases = j["phases"] if "phases" in j else compile_phase_list(j)
    for phase in phases:
        py_state = game.get_state()

        if py_state["name"].endswith("R") and all(
            x.split()[2] != "R" for xs in game.get_all_possible_orders().values() for x in xs
        ):
            # skip R phase with no possible retreats
            process_py_game(game, phase["orders"])
            continue

        print('LOG(INFO) << "\\nTesting state:', phase["name"], '";')
        print_state_tests(py_state)

        if game.get_state()["name"] == "COMPLETED":
            break

        # print('LOG(INFO) << "\\nTesting orders:', phase["name"], '";')
        # print_possible_orders_tests(game)

        print('LOG(INFO) << "\\nPreparing to process:', phase["name"], '";')
        print_orders_and_process(phase["orders"])
        process_py_game(game, phase["orders"])

    print(FOOTER)
